#include<iostream>
//#include<deque>
//#include<vector>
//using namespace std;
//
//class MonotonicQueue
//{
//public:
//	deque<int> dq;
//	
//	void push(int n)
//	{
//		while (!dq.empty() && dq.back() < n)
//		{
//			dq.pop_back();
//		}
//		dq.push_back(n);
//	}
//
//	void pop(int n)
//	{
//		if (dq.front() == n)
//		{
//			dq.pop_front();
//		}
//	}
//
//	int max()
//	{
//		return dq.front();
//	}
//};
//
//vector<int> maxSlidingWindow(vector<int>& nums, int k)
//{
//	MonotonicQueue window;
//	vector<int> res;
//	int len = nums.size();
//	
//	for (int i = 0; i < len; i++)
//	{
//		if (i < k - 1)
//		{
//			window.push(nums[i]);
//		}
//		else
//		{
//			window.push(nums[i]);
//			res.push_back( window.max());
//			window.pop(nums[i - k + 1]);
//		}
//	}
//	return res;
//}
//
//int main()
//{
//	return 0;
//}
//#include<iostream>
//#include<vector>
//#include<stack>
//#include<algorithm>
//using namespace std;
//
//int largestRectangleArea(vector<int>& heights) {
//    int n = heights.size();
//    vector<int> ans(n);
//    stack<int> st;
//    int ser,ser1;
//    int i = 0;
//    while (i < n)
//    {
//        if (st.empty() || heights[st.top()] <= heights[i])
//        {
//            st.push(i);
//            i++;
//        }
//        else
//        {
//            ser = st.top();
//            st.pop();
//            if (st.empty())
//            {
//                ser1 = 0;
//            }
//            else
//            {
//                ser1 = st.top()+1;
//            }
//            ans[ser] = heights[ser] * (i - ser1);
//        }
//    }
//    while (!st.empty())
//    {
//        ser = st.top();
//        st.pop();
//        if (st.empty())
//        {
//            ser1 = 0;
//        }
//        else
//        {
//            ser1 = st.top()+1;
//        }
//        ans[ser] = heights[ser] * (n - ser1);
//    }
//    sort(ans.begin(), ans.end());
//    return *(ans.rbegin());
//}
//
//int main()
//{
//    vector<int> v = { 2,1,2 };
//    int res = largestRectangleArea(v);
//    cout << res << endl;
//}
